;
; Copyright 2014 Luís Puhl <luispuhl@gmail.com>
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are
; met:
;
; * Redistributions of source code must retain the above copyright
;	notice, this list of conditions and the following disclaimer.
; * Redistributions in binary form must reproduce the above
;	copyright notice, this list of conditions and the following disclaimer
;	in the documentation and/or other materials provided with the
;	distribution.
; * Neither the name of the	nor the names of its
;	contributors may be used to endorse or promote products derived from
;	this software without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
; A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
; SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
; LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;
;**************************************************************************
;																		 *
;	Filename: 3-trabalho-1.asm										*
;	Date: 13/05/2014													*
;	File Version: 1													 *
;	Author:	Luís Puhl												*
;	Company: UNESP													*
;	Description: trabalho 1 microcontroladores 2014					 *
;																		*
;*************************************************************************
;																		 *
;	Notes: In the MPLAB X Help, refer to the MPASM Assembler
;	documentation for information on assembly
;	instructions.
;
;**************************************************************************
;																		*
;	Known Issues: This template is designed for relocatable code.	As
;	such, build errors such as "Directive only allowed when generating an
;	object file" will result when the 'Build in Absolute Mode' checkbox is
;	selected in the project properties.	Designing code in absolute mode
;	is antiquated - use relocatable mode.
;																	 *
;**************************************************************************
;																		 *
;	Revision History:												 *
;																		 *
;**************************************************************************



;*************************************************************************
; Processor Inclusion
;
; TODO Step #1 Open the task list under Window > Tasks.	Include your
; device .inc file - e.g. #include <device_name>.inc.	Available
; include files are in C:\Program Files\Microchip\MPLABX\mpasmx
; assuming the default installation path for MPLAB X.	You may manually
; find the appropriate include file for your device here and include it, or
; simply copy the include generated by the configuration bits
; generator (see Step #2).
;
;**************************************************************************

; TODO INSERT INCLUDE CODE HERE
#include<p16f873.inc> ; define o pic a utilizar


;*************************************************************************
;
; TODO Step #2 - Configuration Word Setup
;
; The 'CONFIG' directive is used to embed the configuration word within the
; .asm file. MPLAB X requires users to embed their configuration words
; into source code.	See the device datasheet for additional information
; on configuration word settings.	Device configuration bits descriptions
; are in C:\Program Files\Microchip\MPLABX\mpasmx\P<device_name>.inc
; (may change depending on your MPLAB X installation directory).
;
; MPLAB X has a feature which generates configuration bits source code.
; Go to Window > PIC Memory Views > Configuration Bits.	Configure each
; field as needed and select 'Generate Source Code to Output'.	The
; resulting code which appears in the
; 'Output Window' > 'Config Bits Source' tab may be copied below.
;
;************************************************************************

; TODO INSERT CONFIG HERE
	__config _XT_OSC & _WDT_OFF & _PWRTE_OFF & _CP_OFF & _BOREN_OFF & _LVP_OFF & _CPD_OFF & _DEBUG_OFF & _WRT_OFF

;Set oscillator to XT,
;watchdog time off,
;low-voltage prog. off

;*************************************************************************
;
; TODO Step #3 - Variable Definitions
;
; Refer to datasheet for available data memory (RAM) organization assuming
; relocatible code organization (which is an option in project
; properties > mpasm (Global Options)).	Absolute mode generally should
; be used sparingly.
;
; Example of using GPR Uninitialized Data
;
;	GPR_VAR		UDATA
;	MYVAR1		 RES		1		; User variable linker places
;	MYVAR2		 RES		1		; User variable linker places
;	MYVAR3		 RES		1		; User variable linker places
;
; Example of using Access Uninitialized Data Section (when available)
; The variables for the context saving in the device datasheet may need
; memory reserved here.
; INT_VAR		UDATA_ACS
; W_TEMP		RES		1	; w register for context saving (ACCESS)
; STATUS_TEMP	RES		1	; status used for context saving
; BSR_TEMP		RES		1	; bank select used for ISR context saving
;
;*************************************************************************

; TODO PLACE VARIABLE DEFINITIONS GO HERE
;	CBLOCK 0X20
;		; variavies
;		byte_enviar_serial		;0x20
;		byte_recebido_serial	;0x21
;		ad_h					;0x22
;		ad_l					;0x23
;		temperatura				;0x24
;	ENDC

	; define os ederecos pelo macro do montador
	#define	byte_enviar_serial		0x20
	#define	byte_recebido_serial	0x21
	#define	ad_h					0x22
	#define	ad_l					0x23
	#define	temperatura				0x24
	#define	count_l					0x25
	#define	count_h					0x26
	#define	count_uh				0x27
	#define DEBUG					0x1

;*************************************************************************
; Reset Vector
;*************************************************************************


;RES_VECT  CODE	0x0000			; processor reset vector
	ORG 0
	GOTO	start				   ; go to beginning of program

;*************************************************************************
; TODO Step #4 - Interrupt Service Routines
;
; There are a few different ways to structure interrupt routines in the 8
; bit device families.  On PIC18's the high priority and low priority
; interrupts are located at 0x0008 and 0x0018, respectively.  On PIC16's
; and lower the interrupt is at 0x0004.  Between device families there is
; subtle variation in the both the hardware supporting the ISR
; (for restoring interrupt context) as well as the software used to
; restore the context
; (without corrupting the STATUS bits).
;
; General formats are shown below in relocatible format.
;
;-------------------------PIC16's and below--------------------------------
;
; ISR	   CODE	0x0004		   ; interrupt vector location
;
;	 <Search the device datasheet for 'context' and copy interrupt
;	 context saving code here.  Older devices need context saving code,
;	 but newer devices like the 16F#### don't need context saving code.>
;
;	 RETFIE
;
;----------------------------PIC18's--------------------------------------
;
; ISRHV	 CODE	0x0008
;	 GOTO	HIGH_ISR
; ISRLV	 CODE	0x0018
;	 GOTO	LOW_ISR
;
; ISRH	  CODE					 ; let linker place high ISR routine
; HIGH_ISR
;	 <Insert High Priority ISR Here - no SW context saving>
;	 RETFIE  FAST
;
; ISRL	  CODE					 ; let linker place low ISR routine
; LOW_ISR
;	   <Search the device datasheet for 'context' and copy interrupt
;	   context saving code here>
;	 RETFIE
;
;*************************************************************************

; TODO INSERT ISR HERE
	ORG	 4
	;
	RETFIE

;*************************************************************************
; MAIN PROGRAM
;*************************************************************************

;MAIN_PROG CODE					  ; let linker place main program

start:
	CALL	configura_serial
	CALL	configura_ad
	CALL	configura_led

espera_pc:
	BCF		STATUS,	RP0
	BCF		STATUS,	RP1
	MOVLW	0x7b
	MOVWF	byte_enviar_serial
	CALL	escrita_serial
	; notifica o inicio

	CALL	leitura_serial			; executa leitura serial

#IFDEF DEBUG
	MOVF	byte_recebido_serial,	W
	MOVWF	byte_enviar_serial
	CALL	escrita_serial
	; notifica o que recebeu
#ENDIF

	MOVF	byte_recebido_serial,	W	;
	SUBLW	D'123'						; subtrai o valor esperado 123  = 0x7B
										; armazena em f
	MOVWF	byte_recebido_serial

#IFDEF DEBUG
	MOVWF	byte_enviar_serial
	CALL	escrita_serial
	; notifica o que recebeu subraido o esperado
#ENDIF


	MOVF	byte_recebido_serial,	F ; compara com o valor
									; se 0 entao recebeu 123
	BTFSS	STATUS, Z				; byte_recebido == W ?
	GOTO	espera_pc				; false
	;true

#IFDEF DEBUG
	MOVLW	0x7b					; termino da recepcao serial
	MOVWF	byte_enviar_serial
	CALL	escrita_serial
#ENDIF

	MOVLW	0x0a
	CALL	delay
loop_leitura_ad:
	CALL	leitura_ad				; executa leitura AD
	; parte alta
	;BANKSEL ad_h
	BCF		STATUS,		RP0
	BCF		STATUS,		RP1

#IFDEF DEBUG
	MOVLW	0x7b					; termino da leitura ad
	MOVWF	byte_enviar_serial
	CALL	escrita_serial
#ENDIF

	MOVF	ad_h,			W		; pega parte alta do AD
	MOVWF	byte_enviar_serial		; prepara envio
	CALL	escrita_serial			; envia
	; parte baixa
	MOVLW	0x03
	MOVF	ad_l,			W		; pega parte baixa do AD
	MOVWF	byte_enviar_serial		; prepara envio
	CALL	escrita_serial			; envia

#IFDEF DEBUG
	MOVLW	0x7b
	MOVWF	byte_enviar_serial
	CALL	escrita_serial
#ENDIF

	; verifica o valor para acender o led
	CALL	converte_ad_temperatura

#IFDEF DEBUG
	MOVLW	D'007'
	MOVWF	byte_enviar_serial
	CALL	escrita_serial
#ENDIF

	MOVF	temperatura,		W
	MOVWF	byte_enviar_serial
	;CALL	escrita_serial

	MOVF	temperatura,		W
	;SUBLW	TEMP_ATIVACAO			; compara com a temperatura esperadas
	SUBLW	D'25'					; compara com a temperatura esperadas
	BTFSS	STATUS, C				; byte_recebido > W ?
	CALL	liga_led				; true
	GOTO	final
	CALL	desliga_led
final:
#IFDEF DEBUG
	MOVLW	D'001'					; termino de tudo
	MOVWF	byte_enviar_serial
	CALL	escrita_serial
	CALL	escrita_serial
#ENDIF

	MOVLW	0x0a
	CALL	delay
	GOTO	loop_leitura_ad				  ; loop forever

; -------------------------------------------------------------------------
; ------------------------------ FUNCOES ----------------------------------
; -------------------------------------------------------------------------

; ------------------------------ SECAO SERIAL -----------------------------
configura_serial:
		; TXSTA: TRANSMIT STATUS AND CONTROL REGISTER (ADDRESS 98h)
		; CSRC: Clock Source Select bit		= 0 (assincrono)
		; TX9: 9-bit Transmit Enable bit	= 0 (sem 9º bit)
		; TXEN: Transmit Enable bit			= 1 (liga o tx)
		; SYNC: USART Mode Select bit		= 0 (assincrono)
		; U-0 :								= 0	(n/a)
		; BRGH: High Baud Rate Select bit	= 1 (High speed)
		; TRMT: Transmit Status bit			= 0 (read-only)
		; TX9D: 9th bit						= 0 (n/a)
		; TXSTA = 0010 0100
		BANKSEL TXSTA
		MOVLW   B'00100100'
		MOVWF   TXSTA

		; RCSTA: RECEIVE STATUS AND CONTROL REGISTER (ADDRESS 18h)
		; SPEN: Serial Port Enable bit			= 1 (enable)
		; RX9: 9-bit Receive Enable bit			= 0 (sem 9º bit)
		; SREN: Single Receive Enable bit		= 0 (N/A)
		; CREN: Continuous Receive Enable bit	= 1 (continuous receive)
		; ADDEN: Address Detect Enable bit		= 0 (N/A)
		; FERR: Framing Error bit				= 0 (read-only)
		; OERR: Overrun Error bit				= 0 (read-only)
		; RX9D: 9th bit of Received Data		= 0 (read-only)
		; RCSTA = 1001 0000
		BANKSEL RCSTA
		MOVLW   B'10010000'
		MOVWF   RCSTA

		; SPBRG = 25
		; calculado para 9600 bps
		BANKSEL SPBRG
		MOVLW   D'25'
		MOVWF   SPBRG
	RETURN
leitura_serial:
		BANKSEL PIR1
		; registrador PIR1 contem as flags individuais de cada uma das
		; interrupcoes perifericas
		; bit RCIF indica se o buffer de entrada esta cheio
		; (entrada serial)
espera_leitura_serial:
		BTFSS   PIR1,   RCIF			; se bit RCIF do registrador PIR1
										; ou seja, se tem coisa a ler
		GOTO	espera_leitura_serial	; nao chegou byte
		BANKSEL RCREG
		MOVF	RCREG, W				; chegou byte
		;BANKSEL	byte_recebido_serial
		BCF		STATUS,		RP0
		BCF		STATUS,		RP1
		;MOVLW	0x7b ; DEBUG
		MOVWF	byte_recebido_serial
	RETURN
escrita_serial:
		; TXSTA:	transmit status and control register
		; TRMT:	 bit de buffer de escrita cheio
		BANKSEL TXSTA
		; caso ainda nao tenha enviado o que esta no buffer
		; espera o envio (anterior)
espera_escrita_serial:
		;TRMT: Transmit Shift Register Status bit
		;1 = TSR empty
		;0 = TSR full
		BTFSS   TXSTA, TRMT				; TRMT == 1? ;
		GOTO	espera_escrita_serial   ; buffer cheio, espere
		;BANKSEL	byte_enviar_serial
		BCF		STATUS,	RP0
		BCF		STATUS,	RP1
		MOVF	byte_enviar_serial,	W	; pega a variavel
		BANKSEL TXREG
		MOVWF   TXREG					; escreve a variavel para o buffer
	RETURN
; ------------------------ SECAO AD --------------------------------------
configura_ad:
		; PORTA = analogico em AN0
		; TRISA = 0000 0001
		BANKSEL	TRISA
		MOVLW	B'00000001'
		MOVWF	TRISA

		; ADCON0 = 01 000 0 0 1
		BANKSEL	ADCON0
		MOVLW	B'01000001'
		MOVWF	ADCON0

		; ADCON1 = 0 000 0000
		; ADFM = 0: ajuste a esquerda
		; XXX
		; PCFG = 0000: configuracao geral (muitos bits)
		BANKSEL	ADCON1
		MOVLW	B'10000000'
		MOVWF	ADCON1
	RETURN
leitura_ad:
		; inicia conversao
		BANKSEL	ADCON0
		BSF		ADCON0,	GO_DONE		; inicia a corvesao

		; espera conversao
espera_conversao:;{
		NOP
		NOP
		NOP
		BTFSC	ADCON0,	GO_DONE		; bit 2 = GO/DONE,
		GOTO	espera_conversao	; se nao pronto
		; se pronto

		; copia os valores
		; 0X3E em ADRESH = 25 Cº
		; 0X41 em ADRESH = 26 Cº
		BANKSEL	ADRESH
		MOVF	ADRESH,		W
		;MOVLW	0X41 ; DEBUG
		;BANKSEL	ad_h
		BCF		STATUS,	RB0
		BCF		STATUS,	RB1
		MOVWF	ad_h

		BANKSEL	ADRESL
		MOVF	ADRESL,		W
		;BANKSEL	ad_l
		BCF		STATUS,	RB0
		BCF		STATUS,	RB1
		MOVWF	ad_l

	RETURN
;}
; ------------------------- SECAO LED ------------------------------------
configura_led:
		BANKSEL TRISB
		MOVLW   B'00000000'	 ; configura todas as portas RB para output
		MOVWF   TRISB

		; desligar todas as saidas da porta b
		BANKSEL PORTB
		MOVLW   B'00000000'
		MOVWF   PORTB
	RETURN
liga_led:
		BANKSEL PORTB
		MOVLW   B'11111111'		 ; liga o pino RB1 somente
		MOVWF   PORTB
	RETURN
desliga_led:
		BANKSEL PORTB
		MOVLW   B'00000000'		 ; desliga todos os pinos port B
		MOVWF   PORTB
	RETURN
converte_ad_temperatura:
		; AD responde a cada 5mv
		; lm35	responde 10mv para cada ºc
		; temperatura = ad/2
		; considerando que 2 bits menos significativos estao em
		; ADRESL (ad_l)
		; BANKSEL	ad_h
		BCF		STATUS,		RP0
		BCF		STATUS,		RP1

		BCF		STATUS,		C		; lipa CARRY
		RRF		ad_l,		F		; coloca em CARRY o bit mais alto
									; do low
		RLF		ad_h,		W		; coloca bit anterior em high
									; armazena em W
		MOVWF	temperatura
	RETURN
delay:
		MOVWF	count_uh
delay_loop_uh:
		MOVLW	0xff
		MOVWF	count_h
delay_loop_h:
		MOVLW	0xff
		MOVWF	count_l
delay_loop_l:
		DECFSZ	count_l
		GOTO	delay_loop_l
		DECFSZ	count_h
		GOTO	delay_loop_h
		DECFSZ	count_uh
		GOTO	delay_loop_uh
	RETURN
	END
